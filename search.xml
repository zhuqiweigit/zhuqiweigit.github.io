<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo notes</title>
    <url>/2021/02/23/hexo%20notes/</url>
    <content><![CDATA[<h1 id="hexo-notes"><a href="#hexo-notes" class="headerlink" title="hexo notes"></a>hexo notes</h1><span id="more"></span>

<ul>
<li><p>新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;hexo notes&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译生成页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地开启服务器并预览</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server   <span class="comment">#一般会在http://localhost:4000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>deploy（一键git提交、push到远端）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>Clean 清理缓存文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
</li>
<li><p>markdown中存在图片：</p>
<p>将pic拷贝到 source/images目录下，并将md中的引用链接也设置为此</p>
</li>
<li><p>主页文章缩略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">在文章内添加 &lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态加载图片</p>
<p>在config中开启pjax</p>
</li>
<li><p>github 鉴权失败问题</p>
<p>在 hexo 项目的根目录，修改 _config.yml ；将 repo 地址，从 https 协议改为 ssh</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:zhuqiweigit/zhuqiweigit.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>lab0-cpp primer</title>
    <url>/2021/10/05/lab0-cpp-primer/</url>
    <content><![CDATA[<p>开始 CMU 15-445 的学习，首先是 lab0。</p>
<p>lab0 主要是 搭建环境 和 熟悉 C++。</p>
<span id="more"></span>

<h2 id="project0-C-primer"><a href="#project0-C-primer" class="headerlink" title="project0 C++ primer"></a>project0 C++ primer</h2><p>P0 的主要任务是，实现 Matrix、RowMatrix 和 RowMatrixOperations 三个 class。</p>
<p>Matrix 是虚基类，RowMatrix 是 Matrix 的一个实现。RowMatrixOperations 是矩阵加法、乘法等的封装。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                         BusTub</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// p0_starter.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Identification: src/include/primer/p0_starter.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (c) 2015-2020, Carnegie Mellon University Database Group</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;common/exception.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Matrix type defines a common</span></span><br><span class="line"><span class="comment"> * interface for matrix operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Construct a new Matrix instance.</span></span><br><span class="line"><span class="comment">   * @param rows The number of rows</span></span><br><span class="line"><span class="comment">   * @param cols The number of columns</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Matrix(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols) : rows_(rows), cols_(cols) &#123; <span class="keyword">this</span>-&gt;linear_ = <span class="keyword">new</span> T[rows * cols]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The number of rows in the matrix */</span></span><br><span class="line">  <span class="keyword">int</span> rows_;</span><br><span class="line">  <span class="comment">/** The number of columns in the matrix */</span></span><br><span class="line">  <span class="keyword">int</span> cols_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Allocate the array in the constructor.</span></span><br><span class="line"><span class="comment">   * TODO(P0): Deallocate the array in the destructor.</span></span><br><span class="line"><span class="comment">   * A flattened array containing the elements of the matrix.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  T *linear_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** @return The number of rows in the matrix */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetRowCount</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** @return The number of columns in the matrix */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetColumnCount</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the (i,j)th matrix element.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE if either index is out of range.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param i The row index</span></span><br><span class="line"><span class="comment">   * @param j The column index</span></span><br><span class="line"><span class="comment">   * @return The (i,j)th matrix element</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if either index is out of range</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> T <span class="title">GetElement</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the (i,j)th matrix element.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE if either index is out of range.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param i The row index</span></span><br><span class="line"><span class="comment">   * @param j The column index</span></span><br><span class="line"><span class="comment">   * @param val The value to insert</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if either index is out of range</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetElement</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, T val)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Fill the elements of the matrix from `source`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE in the event that `source`</span></span><br><span class="line"><span class="comment">   * does not contain the required number of elements.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param source The source container</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if `source` is incorrect size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">FillFrom</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;source)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Destroy a matrix instance.</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">virtual</span> ~Matrix() &#123; <span class="keyword">delete</span> []<span class="keyword">this</span>-&gt;linear_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The RowMatrix type is a concrete matrix implementation.</span></span><br><span class="line"><span class="comment"> * It implements the interface defined by the Matrix type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RowMatrix</span> :</span> <span class="keyword">public</span> Matrix&lt;T&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Construct a new RowMatrix instance.</span></span><br><span class="line"><span class="comment">   * @param rows The number of rows</span></span><br><span class="line"><span class="comment">   * @param cols The number of columns</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  RowMatrix(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols) : Matrix&lt;T&gt;(rows, cols) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data_ = <span class="keyword">new</span> T *[rows];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;data_[i] = Matrix&lt;T&gt;::linear_ + i * cols;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   * @return The number of rows in the matrix</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetRowCount</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Matrix&lt;T&gt;::rows_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   * @return The number of columns in the matrix</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">GetColumnCount</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Matrix&lt;T&gt;::cols_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Get the (i,j)th matrix element.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE if either index is out of range.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param i The row index</span></span><br><span class="line"><span class="comment">   * @param j The column index</span></span><br><span class="line"><span class="comment">   * @return The (i,j)th matrix element</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if either index is out of range</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">T <span class="title">GetElement</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= GetRowCount() || j &lt; <span class="number">0</span> || j &gt;= GetColumnCount()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Exception(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;RowMatrix::GetElement() out of range.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;data_[i][j];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Set the (i,j)th matrix element.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE if either index is out of range.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param i The row index</span></span><br><span class="line"><span class="comment">   * @param j The column index</span></span><br><span class="line"><span class="comment">   * @param val The value to insert</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if either index is out of range</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetElement</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, T val)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= GetRowCount() || j &lt; <span class="number">0</span> || j &gt;= GetColumnCount()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Exception(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;RowMatrix::SetElement() out of range.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;data_[i][j] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Fill the elements of the matrix from `source`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Throw OUT_OF_RANGE in the event that `source`</span></span><br><span class="line"><span class="comment">   * does not contain the required number of elements.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param source The source container</span></span><br><span class="line"><span class="comment">   * @throws OUT_OF_RANGE if `source` is incorrect size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FillFrom</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;source)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(source.size()) != Matrix&lt;T&gt;::rows_ * Matrix&lt;T&gt;::cols_) &#123;</span><br><span class="line">      <span class="keyword">throw</span> Exception(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;RowMatrix::FillForm() has incorrect size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Matrix&lt;T&gt;::rows_; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Matrix&lt;T&gt;::cols_; j++) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data_[i][j] = source[idx++];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * TODO(P0): Add implementation</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Destroy a RowMatrix instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ~RowMatrix() <span class="keyword">override</span> &#123; <span class="keyword">delete</span> []<span class="keyword">this</span>-&gt;data_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A 2D array containing the elements of the matrix in row-major format.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * TODO(P0):</span></span><br><span class="line"><span class="comment">   * - Allocate the array of row pointers in the constructor.</span></span><br><span class="line"><span class="comment">   * - Use these pointers to point to corresponding elements of the `linear` array.</span></span><br><span class="line"><span class="comment">   * - Don&#x27;t forget to deallocate the array in the destructor.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  T **data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The RowMatrixOperations class defines operations</span></span><br><span class="line"><span class="comment"> * that may be performed on instances of `RowMatrix`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RowMatrixOperations</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Compute (`matrixA` + `matrixB`) and return the result.</span></span><br><span class="line"><span class="comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span></span><br><span class="line"><span class="comment">   * @param matrixA Input matrix</span></span><br><span class="line"><span class="comment">   * @param matrixB Input matrix</span></span><br><span class="line"><span class="comment">   * @return The result of matrix addition</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt; Add(<span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;</span><br><span class="line">    <span class="comment">// TODO(P0): Add implementation</span></span><br><span class="line">    <span class="keyword">if</span> (matrixA-&gt;GetColumnCount() != matrixB-&gt;GetColumnCount() || matrixA-&gt;GetRowCount() != matrixB-&gt;GetRowCount()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrixA-&gt;GetRowCount();</span><br><span class="line">    <span class="keyword">int</span> col = matrixA-&gt;GetColumnCount();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt; matrix_c(<span class="keyword">new</span> RowMatrix&lt;T&gt;(row, col));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        matrix_c-&gt;SetElement(i, j, matrixA-&gt;GetElement(i, j) + matrixB-&gt;GetElement(i, j));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matrix_c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Compute the matrix multiplication (`matrixA` * `matrixB` and return the result.</span></span><br><span class="line"><span class="comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span></span><br><span class="line"><span class="comment">   * @param matrixA Input matrix</span></span><br><span class="line"><span class="comment">   * @param matrixB Input matrix</span></span><br><span class="line"><span class="comment">   * @return The result of matrix multiplication</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt; Multiply(<span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;</span><br><span class="line">    <span class="comment">// TODO(P0): Add implementation</span></span><br><span class="line">    <span class="keyword">if</span> (matrixA-&gt;GetColumnCount() != matrixB-&gt;GetRowCount()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt;(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> row = matrixA-&gt;GetRowCount();</span><br><span class="line">    <span class="keyword">int</span> col = matrixB-&gt;GetColumnCount();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt; matrix_c(<span class="keyword">new</span> RowMatrix&lt;T&gt;(row, col));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">        T elem = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ptr = <span class="number">0</span>; ptr &lt; matrixA-&gt;GetColumnCount(); ptr++) &#123;</span><br><span class="line">          elem += matrixA-&gt;GetElement(i, ptr) * matrixB-&gt;GetElement(ptr, j);</span><br><span class="line">        &#125;</span><br><span class="line">        matrix_c-&gt;SetElement(i, j, elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix_c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Simplified General Matrix Multiply operation. Compute (`matrixA` * `matrixB` + `matrixC`).</span></span><br><span class="line"><span class="comment">   * Return `nullptr` if dimensions mismatch for input matrices.</span></span><br><span class="line"><span class="comment">   * @param matrixA Input matrix</span></span><br><span class="line"><span class="comment">   * @param matrixB Input matrix</span></span><br><span class="line"><span class="comment">   * @param matrixC Input matrix</span></span><br><span class="line"><span class="comment">   * @return The result of general matrix multiply</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;RowMatrix&lt;T&gt;&gt; GEMM(<span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixB,</span><br><span class="line">                                            <span class="keyword">const</span> RowMatrix&lt;T&gt; *matrixC) &#123;</span><br><span class="line">    <span class="keyword">auto</span> matrix_temp = Multiply(matrixA, matrixB);</span><br><span class="line">    <span class="keyword">if</span> (matrix_temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> matrix_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Add(matrix_temp.get(), matrixC);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在提交之前，可以先用本地的 gtest 测试一下。</p>
<p>提交前，需要用代码格式化工具和代码静态检查工具检查一下代码风格。</p>
<p>最后将代码提交到 gradescope，需要注册，注册码在官网 QA 页面。</p>
<p>实验结果：</p>
<img src="../images/dbp0_0.png" alt="dbp0_0" style="zoom:40%;" />
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>lab2-raft</title>
    <url>/2021/04/13/lab2-raft/</url>
    <content><![CDATA[<p>最近完成了6.824的lab2，记录一下笔记。</p>
<p>lab2的内容是实现raft协议。整个实验的内容分为3部分，lab2-A实现raft的选举机制，lab2-B实现raft的日志追加机制，lab2-C实现raft的持久化。</p>
<span id="more"></span>

<p>完成实验的过程整体上可以分为两方面，其一是理解raft算法原理和细节，其二是设计和具体实现。</p>
<p>以下内容也从这两方面分别介绍</p>
<h2 id="raft-算法原理和细节"><a href="#raft-算法原理和细节" class="headerlink" title="raft 算法原理和细节"></a>raft 算法原理和细节</h2><p>为了对大规模数据进行处理，单机就成为了瓶颈，解决的办法就是使用更多的机器协同工作。而由于计算机本身的物理特性，其存在一定的崩溃概率，另外计算机网络也是计算机集群工作时出现故障的潜在原因（网络分隔、数据包丢失、数据包未按序到达）。如何使得由网络连接的计算机之间能协调一致工作，在某个机器故障or网络故障后，整个系统依然能正常运转，这就是一致性算法的目标。一致性算法用来组织机器执行指令，并使得其最终状态是一致的，在这个过程中能容许部分节点的故障or失败。</p>
<p>raft是一种管理复制日志的一致性算法，它主要分为三个部分，选举、日志复制、安全性。raft算法会从整个集群中选举出一个leader，其它节点称为follower。每次客户端的command会先记录在leader的日志中，然后由leader负责同步给follower。当一条日志同步数目过半后，leader就可以commit这条日志，并把它应用到自己的状态机。说白了采用raft算法的系统中是采用投票机制来达成共识的，因此3个节点的系统中，只要2个节点一致了，整个系统就算做达成了共识。所以3个节点的系统可以容忍1个节点故障，5个节点的系统可以容忍2个节点的故障。</p>
<p>下图是raft原论文中的，理解了这张图，外加一些选举安全性的说明，实现raft算法就基本没问题了。</p>
<img src="../images/raft0.png" alt="raft0" style="zoom:80%;" />

<h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>raft使用心跳机制来实现leader的感知。即leader周期性的广播心跳信息给follower，follower由此得知leader的存在。如果follower在一段时间内没有收到心跳数据(可能是leader和它之间的网络中断了，也可能是leader故障了)，则它会认为leader已经死了，因此自己会变成candidate，并发起投票。如果它可以得到半数的票，就可以当选为新的leader。</p>
<p>follower变成canditate之后立即发起投票，这包含如下几个动作：term加一，自己投自己，重置自己的选举计时器，然后群发自己的请求投票RPC。</p>
<p>接收者收到candidate的投票请求后，先检查term。term相当于一个逻辑时钟，标志着现在发起投票的人处于哪一时代。如果term比自己的老，则可以直接拒绝。否则，结合日志的term、index(candidate的日志必须和自己的一样新or比自己的还新)，voteFor(未投过票就投给它，投过它就直接返回给它true，已经投给别人了就返回false)来判断是否投票给它。</p>
<p>当candidate变成leader以后，他需要立即群发心跳信息，以阻止其它人继续选举。相应地，如果一个节点收到了term比自己新的心跳信息，它就知道已经有leader了，自己就需要老老实实做follower。</p>
<p>为避免大家同时开始发起选举，然后都自己给自己投票，陷入僵局，可以把每个人的选举计时器都设置为随机时间，比如在300ms到400ms之间浮动。</p>
<p><strong>对于任何接收者来说，如果接收到的RPC消息中的term比自己的term大，自己就需要转变为follower</strong></p>
<p>另外，voteFor什么时候重置为空呢？由voteFor的定义可以知道，它是<strong>代表本节点在当前term投票给了谁</strong>，因此代码中任何发生Term变动的地方，都需要重置voteFor。</p>
<h3 id="复制日志"><a href="#复制日志" class="headerlink" title="复制日志"></a>复制日志</h3><p>上层应用把cmd发送给leader，然后leader把它写入自己的日志，然后把自己的日志传送给集群中的大多数节点。由于<strong>由于心跳和日志追加都是leader发送给其他人的，因此两者可以合并起来，当追加日志的RPC中log为空，就表示这是心跳信息，否则这既是心跳信息，也是日志追加信息。</strong>具体实施就是：每次该发送心跳的时候，如果有需要传送的日志，就带上，没有就只发送空消息。</p>
<p>复制日志的大体流程是：上层应用调用leader的start，把cmd传送给它。leader把cmd添加到自己的log中，在下一次心跳计时器到期后，发送给follower，follower会回复是否成功复制到自己的log，如果成功，则leader在自己的matchIndex数组记录一下。根据matchIndex，如果有半数以上的节点都复制了这条消息，leader就把它commit掉。在下一次心跳时，leader会告诉每个follower自己的commit的进度，然后follower会跟随leader也commit。</p>
<p>会有一个后台线程，不断把commit的cmd应用到状态机，一旦一条日志应用到了状态机，它就可以被返回给上层应用。</p>
<p>由于集群中任何时刻都可能有节点故障，因此存在follower的日志和leader的日志不一致的情况。根据raft的思想，以leader为主，冲突的follower的日志需要服从leader的日志（这是因为leader是得到大多数选票而选出来的，这也意味着它的日志比大多数人的都要新or一样新），服从leader也就是少数服从多数。</p>
<p>处理冲突需要leader和follower协商，一直找到双方都一致的那个点，然后重传从那个点以后的所有日志。协商机制可以通过leader的nextIndex数组实现。nextIndex数组在leader刚选出来的时候初始化为leader的日志末尾的下一个index，然后leader开始发送log后，如果收到follower的回复为false，表示这些日志没有匹配上，因此leader开始递减nextIndex，发送新的从nextIndex到末尾的日志过去，这样反复直到匹配成功。匹配的原理是，leader的某个index上的日志，必须和其它节点在该index上的日志一致。而我们不能靠检查日志内容来断定是否一致，而是通过Term来判断。即不同节点上的确定的index上的日志的term相等，则他们一致。</p>
<p>matchIndex表示双方截至目前匹配成功的index，在leader刚选举出来的时候初始化为0，表示leader不知道当前的匹配情况，然后可以随着leader和follower协商处理冲突日志的成功，而得知当前的匹配进度，从而更新matchIndex。matchIndex表示了leader和集群内所有节点的一致性匹配情况，因此可以用于提交log。当leader检查matchIndex，发现某一条日志被复制到了大多数节点后，就可以更新commitIndex，实现提交。<strong>当然，根据论文中的fig8，提交还有一个小细节，即leader更新commitIndex的这一条日志的Term必须是当前Term，不能是旧的Term，这一点随后解释</strong></p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ol>
<li><p>选举安全：领导人的log中必须包括所有已提交的条目，换句话说，只有包含所有已提交的条目的节点才能被选为领导人。</p>
<p>实现这一点，是通过投票限制实现的：follower节点只会给日志比自己新or和自己一样新的人投票。这里的新的定义是：看最后一条日志，如果其Term更大，那就更新。如果Term相等，就看日志Index的大小或者说日志的长度，长度更长的就更新。</p>
<p>因此为了方便比较，candidate会在请求投票的RPC中携带最后一条日志的term和index，方便follower比较。</p>
</li>
<li><p>Leader不允许提交之前Term的日志条目，只能提交当前term的日志条目。</p>
<img src="../images/raft1.png" alt="raft1" style="zoom:70%;" />

<p>如上图所示，s1在term1时当选为leader，复制了2条消息，然后故障崩溃。s5在term2时当选为leader(凭借s3 s4和自己的票)，然后复制了1条消息，后故障崩溃。然后s1在term3时当选为leader，把黄色的消息给s3复制了一份，此时黄色消息已经在集群中复制过半了。<strong>如果允许s1作为leader提交这条黄色的消息</strong>，则存在可能，s1将消息应用到了自己的状态机，而s2和s3还没来得及commit or 应用黄色消息，就被图(d)中新当选的leader s5覆盖成了蓝色消息，随后提交蓝色消息并apply。此时，系统中出现了两种状态，在index=2的位置，s1为黄色消息，s2位蓝色消息。</p>
<p>为了应对这种不一致现象，<strong>规定，图(c)时刻，s1作为leader只能通过提交自己term的红色消息的方式间接提交旧term的消息，即s1观察到红色消息复制到了大多数，然后推进commitIndex为红色消息的index，从而间接把之前term的黄色消息也提交了。而不能直接通过观察到黄色消息已经过半，而推进commitIndex为黄色消息的index，因为这有可能会导致不一致状态</strong></p>
</li>
</ol>
<h2 id="lab2实现"><a href="#lab2实现" class="headerlink" title="lab2实现"></a>lab2实现</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>系统中主要有三个线程负责系统的功能，分别是：heartBeat线程，负责定期发送心跳信息or追加日志；election线程，当选举计时器超时后，负责发起选举；apply线程，负责在后台定期监控当前是否有可以apply的日志(当applyIdx &lt; commitIdx时表示有可以应用的日志)。这三个线程以loop死循环的形式存在，直到上层应用发起kill命令后才退出。</p>
<p>loop内部需要周期性执行handle函数，采用了go内置的定时器，如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">electionMonitorLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.electionTimer.C:</span><br><span class="line">			rf.electionHandle()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">heartBeatSendLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.heartBeatTimer.C:</span><br><span class="line">			rf.heartBeatHandle()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">applyLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.stopCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.applyTimer.C:</span><br><span class="line">			rf.applyHandle()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当计时器到期后，进入对应的handle函数，并在函数内部先重置自己的计时器，然后处理相应的事件。</p>
<p>关于timer的重置，有一些坑，下面的版本是基本正确的版本。坑主要在：当正在执行某个handle时，有可能新的定时的时间又到期了，这时底层会把信号写入到timer.C的channel中，此时直接重置timer是没用的，因为信号已经写入channel了，下个循环依旧会执行handle函数，想要下个循环不执行这个handle函数，需要把这个信号从channel消耗掉。</p>
<p>但是直接消耗也不对，因为stop函数返回false有两种可能，其一是timer到期了，信号写入channel，但没有被消耗；其二是timer到期了，信号写入channel，已经被消耗了。如果看到stop为false，就直接去消耗channel，就可能会阻塞在这里。因此可以采用select的方式，如果当前channel有数据，就消耗，如果没有，就走default分支。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span> <span class="title">resetHeartBeatTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !rf.heartBeatTimer.Stop() &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-rf.heartBeatTimer.C:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rf.heartBeatTimer.Reset(HeartBeatTimeoutMs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="一些bug"><a href="#一些bug" class="headerlink" title="一些bug"></a>一些bug</h3><ol>
<li><p>选举：candidate发送请求投票的RPC并返回结果、统计票数时，不必等所有的RPC都返回结果了再统计数据，尤其是不能阻塞等所有RPC都返回才统计，因为集群中可能存在网络故障or节点故障，某个RPC可能很久才返回结果or永远都无法返回结果。正确的做法是，统计支持的票数和返回的票数，支持票数过半即判定为成功，返回票数达到一半即判定为失败。</p>
</li>
<li><p>选举：RPC调用相当耗时，注意在RPC调用前释放锁。</p>
</li>
<li><p>日志追加：go语言的slice是引用，a := b[1:3]，a仅仅是指向b的引用，不是拷贝。因此在准备appendEntry的RPC的参数时，参数里的日志必须显式调用copy，从raft节点上复制日志，不能直接用引用的方式。否则，由于rpc的call之前会释放锁，而rpc参数又引用了raft的log数据，会发生data race</p>
</li>
<li><p>日志追加：follower节点根据leader的log数据覆盖自己的log的时候，需要考虑到多个RPC数据的先后顺序不一致的问题。比如，leader先发送[1,2]，后发送[1,2,3,4]。但由于网络拥塞，长日志先到，短日志后到，如果在follower端没有处理好如何覆盖的问题，有可能会导致短日志覆盖了长日志。</p>
<p>也不能仅仅覆盖leader发来的日志数据。假如follower中数据为[1,2,3,4,a,b,c,d]，从1开始冲突，而leader发送的数据为[101,102,103,104]，如果仅仅覆盖的话，follower会变成[101,102,103,104, a,b,c,d]，而我们期待的是[101,102,103,104]。</p>
<p>因此正确的做法是：拿到leader的log数据后，先按顺序匹配，直到匹配到不一致的地方，表示从此处到结尾的数据都是冲突的，删除从此处一直到结尾的数据，再把leader log匹配剩下的数据追加到follower</p>
</li>
<li><p>日志追加：需要考虑到网络延迟、数据包未按序到达的情况。日志追加时，leader收到follower的reply的顺序不一定是按序的。比如先发送[1:5]的log数据，许久未收到对应的reply，后leader收到上层通过start发送的消息多了几条，在下次心跳时发送了[1:10]的数据给follower。过了很久，[1:10]的reply先到，leader将这个follower的matchIndex改为10，随后[1:5]的reply后到，leader此时不能把matchIndex再改为5。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lab1-mapReduce</title>
    <url>/2021/03/29/lab1-mapReduce/</url>
    <content><![CDATA[<p>最近开始学习MIT的分布式课程，首先做了lab1。</p>
<p>lab1的内容是mapReduce，关键有两部分，一是理解mapReduce的原理，二是实现分布式的mapReduce。</p>
<p>以下内容也从这两部分着手</p>
<span id="more"></span>

<h2 id="MapReduce-的原理"><a href="#MapReduce-的原理" class="headerlink" title="MapReduce 的原理"></a>MapReduce 的原理</h2><p>下图是一个word count 程序在mapReduce上的原理图。本图仅仅涉及worker节点，master节点未画出。master节点主要起 给worker节点分配工作的作用。</p>
<p><img src="../images/mapreduce.jpg" alt="mapreduce"></p>
<p>顾名思义，mapReduce就是将<strong>可分割</strong>的任务划分成两个阶段完成</p>
<ul>
<li>map阶段将原始数据(如文件内容)拆分成了一个个key-value pair的形式</li>
<li>reduce阶段将这些拥有相同key的pair聚集在一起，进行某种用户自定义的汇总运算。</li>
</ul>
<p>mapReduce 的例子</p>
<ul>
<li>单词计数：map函数将content拆分成 {word, “1”}的形式；reduce将聚集在一起的相同的word的进行频率计数，输出{word, “1023”}的形式</li>
<li>倒排索引：由单词找文档。map函数将{docName, content} 拆分为 {word, docName}的list；reduce将聚集在一起的相同的word，的对应的docName进行排序并汇总</li>
</ul>
<h2 id="分布式的MapReduce"><a href="#分布式的MapReduce" class="headerlink" title="分布式的MapReduce"></a>分布式的MapReduce</h2><h3 id="1-master"><a href="#1-master" class="headerlink" title="1. master"></a>1. master</h3><p>分布式的MapReduce采用C/S的模式，其中master作为服务端，worker节点作为客户端。即分布式MapReduce的运行模式为：worker节点通过RPC不断向master节点请求任务，master节点根据自己的数据结构记录的任务情况来给worker节点分配任务(通过RPC返回任务的meta description)。worker节点获取任务meta信息后，通过分布式文件系统获取文件，并完成任务的计算。</p>
<p>Master的主要数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//待处理的n个文件</span></span><br><span class="line">	files []<span class="keyword">string</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">//map任务的meta描述，凭借这个来分配map任务</span></span><br><span class="line">	mapTasks   []Task</span><br><span class="line">	mapTaskPtr <span class="keyword">int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//reduce任务的meta描述，凭借这个来分配reduce任务</span></span><br><span class="line">	reduceTasks   []Task</span><br><span class="line">	reduceTaskPtr <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当前已完成的task计数，用于判断每个阶段的任务是否完成</span></span><br><span class="line">	mapCompleteCnt <span class="keyword">int</span></span><br><span class="line">	reduceCompleteCnt <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//mutex互斥保护变量：RPC是并发的，因此需要互斥访问Master的meta data</span></span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>描述任务的数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//任务类型，分为：Map任务，Reduce任务，IDLE空闲任务</span></span><br><span class="line">	taskType_ <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	taskId_ <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//任务状态：待分配、已分配、已完成</span></span><br><span class="line">	taskState_ <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Master主要需要实现两个RPC接口供Worker调用：</p>
<ul>
<li>AskForTask：请求任务，该接口会根据任务分配和完成情况，返回一个task。具体来说，当所有map任务<strong>完成</strong>后，才可以继续分配reduce任务。如果所有map任务都已经分配出去，但并没有全部收到commit，说明部分map任务还在被执行，此时如果有worker请求任务，应该给它分配IDLE任务。</li>
<li>CommitTask：提交任务，该接口会将一个已分配任务的状态改为已完成</li>
</ul>
<h3 id="2-worker"><a href="#2-worker" class="headerlink" title="2. worker"></a>2. worker</h3><p>worker作为客户端，不断调用Master提供的AskForTask请求任务，当获得一个任务后，就开始执行，执行完毕后调用CommitTask提交任务。然后循环继续请求新的任务。</p>
<p>worker每次请求任务都是通过RPC，当RPC向Master节点发起连接时，如果连接失败，说明master损坏，or整个mapReduce任务已经完成且master已退出。此时worker也退出即可。</p>
<p>worker执行任务的流程则如文章一开始画的图一样。</p>
<h3 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3. 错误处理"></a>3. 错误处理</h3><p>master故障：只需要将master节点的meta-data信息周期性写入磁盘，当master故障时，重启一个新节点并load这个meta-data即可继续执行master的功能。当然一般来说master是不允许有故障的，如果出现了故障，直接停止整个程序的运行，让用户检查故障也是一种方法</p>
<p>worker故障：如果worker发生了故障，则worker的任务需要由其它worker重新完成</p>
<ul>
<li>master端：master分配一个任务给worker后，会启动一个协程来监控任务的完成情况。具体来说，可以设置一个定时器，当10s后检查该任务是否已经由worker提交，且任务的状态改为“已完成“。如果否，则说明worker可能存在故障，只需要将该任务从 “已分配”的状态改为“待分配”，即可。</li>
<li>worker端：worker的任务提交必须是原子性的，即worker在运行中生成的文件是私有的，可以将其命名为temp文件。只有当任务完成后，才将temp文件改成标准命名的文件，使得其它worker节点可见，然后再向master节点commit任务。这样做的原因是，如果worker在执行任务的过程中直接使用标准命名的文件，当work节点挂掉后，其它work节点会重做该task，但此时出现了file name的冲突。</li>
</ul>
<h3 id="4-go编程的一些note"><a href="#4-go编程的一些note" class="headerlink" title="4. go编程的一些note"></a>4. go编程的一些note</h3><p>刚开始尝试go编程，记录一些go的语法</p>
<ul>
<li><p>RPC</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.RPC传递的struct的成员必须大写</span></span><br><span class="line"><span class="keyword">type</span> TaskRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pad <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.RPC的接口函数格式; 请求消息和返回消息通过函数参数传递，因此需要使用引用传递；返回值必须是error类型，若没有错误则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span> <span class="title">CommitTask</span><span class="params">(request *CommitRequest, response *CommitResponse)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fmt 相关</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. %v可打印各种变量</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;open file [%v] failed  %v&quot;</span>, fileName, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Sprintf 格式化输出字符串</span></span><br><span class="line">str := fmt.Sprintf(<span class="string">&quot;tmp-mr-%v-%v&quot;</span>, mapTaskId, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Sscanf 从字符串格式化读入数据; n表示读到了几个数据</span></span><br><span class="line">n, err := fmt.Sscanf(str, <span class="string">&quot;mr-%v-%v&quot;</span>, &amp;map_id, &amp;reduce_id)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. Fprintf 向文件中格式化输出数据</span></span><br><span class="line">fmt.Fprintf(filePtr, <span class="string">&quot;%v %v\n&quot;</span>, key, val)</span><br></pre></td></tr></table></figure>
</li>
<li><p>json</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 直接把struct数据写入到文件中，以json格式</span></span><br><span class="line">encoder := json.NewEncoder(filePtr)</span><br><span class="line">err := encoder.Encode(kvaStruct)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 从文件中把json解码，并读入为struct</span></span><br><span class="line">decoder := json.NewDecoder(f)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		kv := KeyValue&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := decoder.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读写文件相关</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.利用ioutil读文件，得到的buf类型为[]byte；readAll读入该文件所有的内容</span></span><br><span class="line">buf, err := ioutil.ReadAll(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.利用ioutil读取目录，得到的是每个文件的描述struct(不是文件指针，也不是fileName)</span></span><br><span class="line">allFilesDescription, err := ioutil.ReadDir(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, fileDes := <span class="keyword">range</span> allFilesDescription &#123;</span><br><span class="line">  fileName := fileDes.Name()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 利用filePtr.Read只能读取缓冲区大小的数据</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">n, err := filePtr.Read(buf)  <span class="comment">//读到的只是1024 bytes大小的数据，不会读完全文</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>lab4-Sharded Key/Value Service</title>
    <url>/2021/05/15/lab4-Sharded-Key-Value-Service/</url>
    <content><![CDATA[<p>MIT分布式原理课程的lab4。最近一直在忙科研上的事情，外加五一假期玩了几天，一直到今天才完成lab4。这篇文章记录lab4的具体情况。lab4的实验分为两个部分：shardmaster和shardKV，这两部分合起来构成一个完整的分布式key-value服务系统。</p>
<span id="more"></span>

<p>我们在lab3已经完成过一个基于raft的分布式kv服务了，但lab3的系统使得整个系统的流量都汇集在一台机器上（即集群的leader节点上），这导致了性能问题。在lab3中，所有client的request都是先访问集群的leader，再由leader将request转换为command并借助raft下发到所有replica机器，达成共识后整个集群一起执行这条command，然后再由leader将执行结果返回给client。可以看出来，集群的leader承担了所有流量。</p>
<p>而lab4的任务就是解决上述性能问题。具体来说，我们将所有的kv数据按照key进行划分，比如最简单的方法，按照key的开头字母进行划分，将所有客户端发出的key划分为‘a’到‘z’的26个集合，每个集合称为一个shard。此外我们有若干个基于raft的分布式集群（每个集群都是一个独立的raft系统），每个集群只需要存储和处理这26个shard中的一个子集。这样，每个client都可以根据我们的划分规则，找到key对应的处理的集群，然后向这个集群发起请求，达到了分担负载的目的。</p>
<p>在实现中，我们不能使用固定分配的规则决定哪个集群负责哪些key。原因有两点：一是请求是动态的，这就导致不同时刻不同集群的负载不同，有时候我们需要在集群之间调整任务实现负载均衡，比如把负载过大的集群上的一些shard调整给负载较小的集群，使之能分担一些任务；二是因为，在分布式系统中，我们想实现一个随时允许集群加入和离开的系统，因此我们要给新加入的集群分配一些shard，把要离开的集群的shard分配给其它集群。</p>
<p>因此，我们需要把”shard如何划分“做成动态的，每个集群定期查询最新的”划分方案“，然后调整自己的负载。这个任务划分的方案称为config。我们需要一个raft集群专门负责给其它集群提供config的查询服务，这个集群叫做master，它仅仅负责提供config查询。其它集群负责具体的key-value的处理，称为shardkv集群。因此lab4的实现也分为两个部分，A部分实现shardmaster，B部分实现shardkv。</p>
<p>整个系统的原理如下：</p>
<img src="../images/shardKV.jpg" alt="shardKV" style="zoom:110%;" />



<h2 id="A-shardmaster"><a href="#A-shardmaster" class="headerlink" title="A. shardmaster"></a>A. shardmaster</h2><p>由上图知道，shardmaster的任务有两个，1）供client查询任意历史config和最新config；2）当client发出移除group或者新增group的指令时，生成一个新的config(要达到负载均衡，即每个移除或新增group后，系统中现存group的任务量要尽量一致)。</p>
<p>一个config如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	Num    <span class="keyword">int</span>              <span class="comment">// config number</span></span><br><span class="line">	Shards [NShards]<span class="keyword">int</span>     <span class="comment">// shard -&gt; gid</span></span><br><span class="line">	Groups <span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span> <span class="comment">// gid -&gt; servers[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Num表示config的编号，通过比较Num就可以知道两个config谁新谁旧。Shard是一个数组，记录着shardId的对应groupId，即记录某个shard分配给哪个group。Group记录每个group内部的所有机器的name。</p>
<p>如何得知一个key的对应shardId是多少呢？lab4中的方案是  shardId = hash(key) mod Nshards。</p>
<p>我们要做的，就是当client发来一个leave group 或者 join group指令后，根据新的group情况重新生成一个config。</p>
<h3 id="join-group"><a href="#join-group" class="headerlink" title="join group"></a>join group</h3><p>当有新的group加入后，我们需要从原有的group上拿出一些shard分配给新的group。原则是：要分配的尽量均匀，并且尽量使shard的移动次数尽量少（因为一个shard就是数据库的一部分数据，移动一次的传输开销很大）。</p>
<p>一个最简单但不可行方案是把所有的N个shard全部按顺序重新分配，比如一共10个shard，原来2个group，新增1个group之后，一共3个group，则group0得到0、1、2号shard，group1得到3、4、5号shard，group2得到6、7、8、9号shard。但这么做违背了上述”使shard的移动次数尽量少“的原则。</p>
<p>一个可行的办法是，可以按照新的group个数计算出每个group平均得到avg个shard。然后遍历每个group，如果有group持有的shard多于avg个，就把多于avg的shard放进一个池子里。然后把池子里的shard按一定的原则逐一分配出去。</p>
<p>这里有一个要注意的地方，就是上述算法是在一个shardmaster集群内的所有raft节点上都执行的，我们必须保证所有节点按照上述算法执行完后，得到相同的结果。因此，我们需要保证算法的一致性。因此在上述算法的基础上，将多于avg的shard放进池子里后，我们分配池子里的shard给group时，为保证一致性，需要一定的原则，这里人为制定一下：</p>
<ul>
<li>分配池子里的shard时，按照shardId从小到大的顺序，一个一个分配。</li>
<li>具体把这个shard分配给哪个group呢？分配给目前拥有shard个数最少的group。如果有多个group符合，则分配给groupId最小的那个group。</li>
</ul>
<h3 id="leave-group"><a href="#leave-group" class="headerlink" title="leave group"></a>leave group</h3><p>当现有的group离开后，我们需要把原本它负责的shard分配给其它group。仍然遵循均匀分配和移动shard次数尽量少的原则。</p>
<p>方法是，把离开的group负责的shard放入池子内。然后依次把池子里的每个shard分配给现存的group。我们仍然需要注意一致性原则。具体细节和join group中的一样。</p>
<h3 id="查询config"><a href="#查询config" class="headerlink" title="查询config"></a>查询config</h3><p>很简单，没什么可说的。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><p>client</p>
<p>client端，和lab3的raftkv一样，遵循线性原则，即：只有当这个请求得到结果后，才会发起下一个请求。考虑到网络环境差可能导致的request的失序、丢失等问题，我们需要给每个client设置一个operationId，初始化为0，每发起一个新的request，就递增operationId，表示上一个request已经得到结果了。在服务端，当收到比当前已经处理过的opeartionId更小的id，说明这是一个失序的request，直接丢弃即可（也可以回复一个ErrOperationOld错误，虽然对端没人接收）。</p>
</li>
<li><p>server端</p>
<ul>
<li><p>线性原则：主要考虑当重复的或者更旧的operationId到来时，如何处理的问题。</p>
</li>
<li><p>snapshot：和lab3一样，也需要做snapshot。shardmaster的状态机包括什么呢？应该至少包括：最后一条被应用到状态机的raft日志的任期lastApplyTerm、最后一条被应用到状态机的raft日志的索引lastApplyIndex、真正的状态机: configs列表、用来实现线性原则的记录每个client最后一条被应用的operation的operationId的lastApplyOperationId</p>
</li>
<li><p>通过负载均衡原则生成新config的算法，上文已经谈到了</p>
</li>
</ul>
</li>
</ul>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><ul>
<li><p>raft的提交问题。如果我们通过raft.Start()提交的指令是某个request，比如LeaveArgs，请注意一个隐秘的bug。即我们很可能通过raft.Start提交的是LeaveArgs * 类型，在raft leader使用go语言的RPC工具向其它replica节点同步这条指令时，go会自动把LeaveArgs * 指针类型转换成正常的LeaveArgs类型然后再通过RPC发送出去，从而replica节点收到的是LeaveArgs类型的数据。但raft leader自己留下的却是LeaveArgs * 指针类型。</p>
<p>当applyLoop开始应用数据时需要把interface数据转回LeaveArgs类型， 此时raft leader会转换失败，而其它replica节点会转换成功。导致出现leader无法apply指令，而其它节点都成功apply指令的错误。</p>
</li>
</ul>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><img src="../images/shardkv_result0.png" alt="image-20210516201206118" style="zoom:50%;" />

<h2 id="B-ShardKV"><a href="#B-ShardKV" class="headerlink" title="B. ShardKV"></a>B. ShardKV</h2><p>shardKV是kv存储的实现关键。它主要有两个任务，一是正常对外提供key-value的GET和PUT服务，这个大致和lab3的raftkv实现一致，唯一的细节就是server端每次在GET或PUT一个kv pair时，需要先检查这个key是否由自己负责，如果不是，需要返回error，其它的不多赘述；二是每个shardKV集群都需要定期从shardmaster处拉取新的config，并根据这个config调整自己的shard的负责情况，接下来主要记录一下这部分的实现。主要可以分为如下几部分：拉取并更新config、根据config调整自己的shard。</p>
<h3 id="更新config"><a href="#更新config" class="headerlink" title="更新config"></a>更新config</h3><p>在一个shardKV集群中，我们需要一个loop定期从shardmaster拉取config。由谁去拉取呢？应该由集群的raft leader 作为一个client，向shardmaster拉取。整个流程为：raft leader 持有一个shardmaster的client对象，并通过它向shardmaster发起Query config的请求。在得到shardmsater的回复并拿到config后，<strong>通过leader的raft层把config下发到集群中所有节点，然后所有节点一起执行(apply)这个config</strong>。</p>
<p>shardmaster中记录了所有的历史config，每次拉取时，应该拉取哪个呢？是最新的config呢还是当前shardkv集群的config的下一个config呢？应该是当前config的下一个config。因为每个shardkv集群的拉取config的进度不一样，因此如果每次都拉取最新的config，很可能会跳过一部分config，导致出现错误。</p>
<p>比如：在config1中，A集群负责shard0，在config2中，B集群负责shard0，在config3中，C集群负责shard0。假设当前ABC集群都处于config1，接着B集群pull config，发现最新的config是config2，它直接跳到config2，接着它发现自己需要获取shard0，从哪里拿呢？它看了一下自己旧的config1，认为shard0在A处，于是它从A处拿到了shard0。过了一会，C集群pull config时，此时最新的config是config3，于是C直接跳到config3，这时C发现自己也需要shard0，它该从哪里拿呢？C看了一下自己的旧的config0，发现shard0在A处，于是C也从A处拿到了shard0。则在此刻，B和C都持有并负责shard0，显然这是错误的。</p>
<p>因此更新config，每次只拿比当前Num大1的config才是正确的。比如上面的场景中，C先过渡到config2，然后再到config3，此时发现自己需要shard0，从哪里获取呢？C查看自己的旧的config2，发现B持有shard0，于是去B索取。如果B开始执行config3了，就会同意C的请求并把自己的shard0给C，如果B还没到config3，就会拒绝这次请求，C请求shard0失败。由此，整个系统中始终只有一个集群持有shard0。</p>
<p>如何apply这个config？集群中所有节点拿到config后，根据config将与自己相关的shard分为3类：原先持有的这次依旧需要持有的shard、原先没有的这次需要持有的shard、原先持有的这次需要抛弃的shard。其中后两种称为needShards和discardShards。</p>
<ul>
<li>原先持有，这次依旧持有的shard：仍旧放在自己的数据库中，且对外提正常的PUT、GET服务。</li>
<li>needShards：需要定时去持有它的shardKV集群索要数据，拿到后放入自己的数据库</li>
<li>discardShards：先把它从正常服务的dataBase中移出去，放在一个专门的容器中，等待它的新config下的持有人索要。</li>
</ul>
<p>注意：<strong>只有当所有的needShards都获取到了之后，才视为本次config apply完毕，才允许拉取和apply下一个config</strong>。每拿到一个needShard，就立即将它加入自己的database，并立即启动该shard的服务。而discardShards就一直留着，什么时候对方索要成功后，什么时候再删掉。</p>
<h3 id="调整shard"><a href="#调整shard" class="headerlink" title="调整shard"></a>调整shard</h3><p>一个shard如下所示，若干个这样的shard就组成了一个shardKV集群的database。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardData <span class="keyword">struct</span> &#123;</span><br><span class="line">	ShardId         <span class="keyword">int</span></span><br><span class="line">	ConfigNum       <span class="keyword">int</span></span><br><span class="line">	Data            <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//key-value</span></span><br><span class="line">	RecentApplyOpId <span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int64</span>   <span class="comment">//clientId-opId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在apply完config后，就需要根据这个config来调整shard了。我们只需要对needShards和discardShards进行处理，且关键是needShards。获取needShards有推和拉两种方式，我在这里采用了拉的方式，即需要这个shard的节点主动向持有者请求该shard。</p>
<p>集群内部由谁负责拉取shard？应该由本集群的raft leader负责拉取，当拉取到<strong>正确configNum下的shard</strong>后，leader通过raft将shard下发给集群内的所有replica节点，然后所有节点一起执行这个shard（将其纳入database，并开启该shard的对外服务）</p>
<p>discardShards的处理？discardShards内存放的是本集群不要的，而其它集群需要的shards。在其它集群通过拉取的方式得到discardShards里的一个shard后，应该通知discardShards的持有集群：可以把这个shard删除掉了，不然长期存着占空间。具体实现方式为：在shard的需求方A集群拉取到一个shard并成功apply到所有节点后，由A集群的leader负责通知对方B可以删除这个shard，然后B收到这个RPC后，由B集群内的leader发起一个删除shard的command，下发到集群内部的所有节点，然后内部所有节点一起执行删除指令。最后由B集群的leader返回给A一个OK表示成功删除。</p>
<h3 id="shardKV的client"><a href="#shardKV的client" class="headerlink" title="shardKV的client"></a>shardKV的client</h3><p>官方代码基本上把client端事先实现好了，但由于和以往的流程不太一样，所以还是记录一下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	args := GetArgs&#123;Key: key, ClientId: ck.clientId, OperationId: ck.operationId&#125;</span><br><span class="line">	ck.operationId++</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		shard := key2shard(key)</span><br><span class="line">		gid := ck.config.Shards[shard]</span><br><span class="line">		<span class="keyword">if</span> servers, ok := ck.config.Groups[gid]; ok &#123;</span><br><span class="line">			<span class="comment">// try each server for the shard.</span></span><br><span class="line">			<span class="keyword">for</span> si := <span class="number">0</span>; si &lt; <span class="built_in">len</span>(servers); si++ &#123;</span><br><span class="line">				srv := ck.make_end(servers[si])</span><br><span class="line">				<span class="keyword">var</span> reply GetReply</span><br><span class="line">				ok := srv.Call(<span class="string">&quot;ShardKV.Get&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; (reply.Err == OK || reply.Err == ErrNoKey) &#123;</span><br><span class="line">					<span class="keyword">return</span> reply.Value</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrWrongGroup) &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrWrongLeader) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ok &amp;&amp; (reply.Err == ErrRaftTimeout) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		<span class="comment">// ask master for the latest configuration.</span></span><br><span class="line">		ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先opeartionId必不可少，这是为防止request的失序、丢失。</p>
<p>client的流程变成了：先向shardmaster请求最新的config，根据config查看自己的key应该发往哪个shardkv集群。然后再向该集群定向发送request请求。</p>
<h3 id="challenge-exercises"><a href="#challenge-exercises" class="headerlink" title="challenge exercises"></a>challenge exercises</h3><ul>
<li><h4 id="Garbage-collection-of-state"><a href="#Garbage-collection-of-state" class="headerlink" title="Garbage collection of state"></a>Garbage collection of state</h4><p>意思是A集群不要的shards，就不需要一直保留了，不然几次config折腾下来，会占存储大量丢弃的shards，占据大量的空间。但如果A集群把它删掉了，那B集群需要这个shard，该怎么办呢？</p>
<p>办法前文已经给出了：每次apply新的config时，把当前集群的shards分为三类，继续持有的shards、needShards和discardShards。对于本challenge，假设集群A的discardShards中就包含了B需要的shard，那只有当B收到这个shard并成功apply后，由B通知A，A才能从discardShards中把该shard删掉。</p>
</li>
<li><h4 id="Client-requests-during-configuration-changes"><a href="#Client-requests-during-configuration-changes" class="headerlink" title="Client requests during configuration changes"></a>Client requests during configuration changes</h4><p>大意是，在更改config的过程中，由于调整并传输shards是个费时的操作，所以我们希望在传输shards的过程中能尽量对外继续提供GET、PUT等服务。</p>
<p>1）我们可以在调整shards的过程中，对三类shard中的继续持有shards继续开放服务。这个在上文已经实现。</p>
<p>2）在拉取多个needShards的时候，拉取成功一个shard，就立即开启这个shard的对外服务。这个也已经实现。</p>
</li>
</ul>
<h3 id="一些bug"><a href="#一些bug" class="headerlink" title="一些bug"></a>一些bug</h3><ul>
<li>依旧是raft.Start()时下发了一个指针类型的数据，导致raft leader 节点 apply的时候转换类型失败的错误。</li>
<li>忘记重置某个timer</li>
</ul>
<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><img src="../images/shardkv_result1.png" alt="image-20210516222359550" style="zoom:50%;" />

]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lab3-Fault tolerant Key/Value Service</title>
    <url>/2021/04/19/lab3-Fault-tolerant-Key-Value-Service/</url>
    <content><![CDATA[<p>MIT6.824分布式原理的课程lab，这篇文章记录lab3的详情。</p>
<p>lab3的实验分为两个任务，一是基于lab2完成的raft协议，完成一个不带日志压缩的 Key Value Service系统；二是在已经搭建好的Key Value Service上实现日志压缩(也即 snapshot)。</p>
<span id="more"></span>

<h2 id="Key-value-service-without-log-compaction"><a href="#Key-value-service-without-log-compaction" class="headerlink" title="Key/value service without log compaction"></a>Key/value service without log compaction</h2><p>Key Value Service 由客户端和服务端组成，其中客户端处于用户的机器上，服务端和它底层的raft处于服务器上，并且每个服务端与对应的raft处于同一个机器，即raft作为底层，负责一致性，而服务端处于上层，负责接受从客户端发来的请求并结合raft的反馈对状态机做相应的修改。</p>
<p>通常，集群由n个服务端组成，只有一个服务端对应的底层raft为leader，也即只有这个服务端是leader。客户端的交互对象就是这个leader服务端。客户端发过来一个command给leader服务端，然后leader服务端把这条command拿去给集群内的follower达成共识，然后commit，一旦commit后，leader就可以把这个command执行（应用）到自己的状态机。</p>
<p>在客户端看来，就好像服务端并没有分布式集群，它仅仅是在和leader进行交互。</p>
<p>具体到本次lab，服务端负责维护的是一个kv数据库，在lab中我们将其简化为一个map[string] string。服务端需要处理三种请求：</p>
<ul>
<li>GET(key)：负责接受一个key，并查询其对应的value，如果没有找到，就返回空字符串。</li>
<li>PUT(key,value)：接受kv pair，并将其放入kv数据库。(如果以前有，就覆盖，如果以前没有，就新增)</li>
<li>APPEND(key,value)：接受kv pair，并将其append到数据库。(以前有，就将新value追加在旧value后面，以前没有，就直接新增)</li>
</ul>
<p>需要注意的是，<strong>Raft需要实现线性化语义</strong>。即作为客户端，只有在成功收到本次command的结果后，才会发起下一次command。不会出现一次性并行发送n条command，然后分别等待它们的结果的情况。</p>
<h3 id="客户端设计"><a href="#客户端设计" class="headerlink" title="客户端设计"></a>客户端设计</h3><p>客户端应该向集群中的leader发送command，但刚开始发送Get、Put之类的时候，它并不知道谁是leader。因此可以采用轮询的策略，当对方不是leader是，客户端会收到 ErrWrongLeader 的错误，这时它就可以向下一个节点发送这条命令了。</p>
<p>raft的线性化语义也必须在客户端得到实现，即：客户端在本条指令未得到结果前不会立刻return。比如下面的Get方法，如果网络拥塞导致超时，那就等待一个时间段然后重试；如果是错误的leader，就重新定位到下一个集群节点，并发送请求；如果是服务端超时，则可能是定位到了partition的leader上，导致command迟迟无法commit，也需要换一个节点发送请求；直到收到正确的结果后才return</p>
<p>另外，对于同一条command，客户端可能会在网络中发送不止一条，所以需要给command编号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">	request := GetArgs&#123;Key: key, ClientId: ck.clientId, OperationId: ck.operationId&#125;</span><br><span class="line">	ck.operationId++</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		response := GetReply&#123;&#125;</span><br><span class="line">		ok := ck.servers[ck.leaderId].Call(<span class="string">&quot;KVServer.Get&quot;</span>, &amp;request, &amp;response)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">			ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">			time.Sleep(RetrySendReqTimeMs)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> response.Err == ErrNoKey &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> response.Err == ErrWrongLeader &#123;</span><br><span class="line">			ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> response.Err == ErrRaftTimeout &#123;</span><br><span class="line">			<span class="comment">//超时，maybe定位到了partition的旧leader上</span></span><br><span class="line">			ck.leaderId = (ck.leaderId + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> response.Err == OK &#123;</span><br><span class="line">			<span class="keyword">return</span> response.Value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;wrong GET reply args&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h3><p>服务端接收从客户端发来的command，并把command通过Start交给raft层。如果raft发现自己不是leader，就会拒绝这个command，并return false，服务端得到false后需要将 ErrWrongLeader 错误反馈给客户端。</p>
<p>如果start成功，则说明command已经交给raft层，由raft层负责达成共识。在达成共识后会通知服务端，服务端就可以apply或者说执行这条command了。</p>
<p>由于考虑到效率问题，整个过程应该是并发的，而考虑到raft层达成一致需要一段时间，因此start 一条command、执行command、反馈结果给客户端 这三个过程应该是异步的。</p>
<img src="../images/kv-Service.jpg" alt="kv-Service" style="zoom:60%;" />

<p>如上图所示，当一个command到达服务端的RPC接口后，服务端将command交给raft层的start函数，并启动一个定时器，然后等待结果。raft层在达成一致后，会把command写入raft.applyCh。服务端的apply Loop收到通知后，开始执行这条command并把结果应用到自己的数据库中。并把结果通过service.applyCh通知到RPC接口，RPC接口收到通知后，返回结果给客户端。如果RPC接口函数迟迟得不到通知，超时定时器就会到期，此时接口函数直接给客户端返回ErrRaftTimeout错误。</p>
<p>图中的raft.applyCh只有一个，用于raft层向service层通知。而service.applyCh有多个，即每次RPC请求，就新创建一个，用于服务端的service Loop向服务端的RPC接口函数通知command结果。 </p>
<p>可以看到，raft层只是用来达成一致的，当它认为集群中过半数的节点都同步了某条指令，它就会使用applyCh把它通知给Service层，告诉service层，你可以放心的执行这条command了。</p>
<p><strong>序列号：</strong>客户端有可能会重发某条指令（比如网络拥塞导致客户端主动重发）这就要保证重发的指令不能被又一次执行，必须返回上次执行过的结果。解决办法就是给command编号，具体来说，使用&lt;clientId, commandId&gt; pair来标识每一条command，其中clientId表示客户端的识别号，commandId表示指令的Id，指令Id是递增的。服务端记录自己最近已经apply到了哪一条指令，当有新指令需要处理时，先检查它的序列号Id是否小于自己上一次处理过的，如果小于，则说明这条指令已经处理过了，直接给用户回复Ok即可(丢弃也行，因为既然更大的command都已经处理过了，说明之前的command用户早已收到结果了)。</p>
<h2 id="Key-value-service-with-snapshots"><a href="#Key-value-service-with-snapshots" class="headerlink" title="Key/value service with snapshots"></a>Key/value service with snapshots</h2><p>partB要求在key value Service 的基础上完成快照功能。</p>
<img src="../images/snapshot.png" alt="snapshot" style="zoom:60%;" />

<img src="../images/snapshotRPC.png" alt="snapshotRPC" style="zoom:60%;" />

<p>在正常运行的过程中，raft会将自己的log持久化，当系统崩溃并重启后，由于没有持久化service层的状态机，所以整个系统都是0状态，因此raft会将自己的commitIdx和applyIdx(这两个数据不需要持久化)重置为0，并从第一条log开始重新执行到最新的log位置。这会浪费大量的时间，并且为了恢复状态，需要保存从系统开机到当前的所有log，这是很占存储空间的。</p>
<p>快照snapshot解决了这个问题，即在某个时间节点把service层的状态机的数据全部保存一份(在这里就是service层的kv数据库)，当系统崩溃重启后，只需要先把snapshot恢复到service层，然后再依次执行快照时间点之后的所有log。</p>
<img src="../images/snapshotServiceRaft.png" alt="snapshotServiceRaft" style="zoom:60%;" />

<p>整个快照机制如上图所示(图来自6.824实验的主页)。</p>
<h3 id="建立快照"><a href="#建立快照" class="headerlink" title="建立快照"></a>建立快照</h3><p>每个节点都会建立自己的快照，包括leader和follower。</p>
<p>service层会定期检测raft层保存在硬盘中的持久化数据的大小(主要是log太占空间)，一旦发现持久化数据文件超过了某个大小，就启动快照机制。service层首先将自己维护的数据库序列化，然后通知raft层将raft层的日志截断，丢弃截断的前面的log。从哪里截断呢？应该从service层保存自己快照的最后一条log截断。之后，将service层序列化的数据和raft层的需要持久化的一些状态一起写入硬盘。建立快照就ok了。</p>
<p>service层需要持久化的数据（写入快照的数据）：自己的数据库、lastApplyIndex、lastApplyTerm、recentApplyOpId</p>
<p>raft层需要持久化的数据和lab2一样，仍然是那些</p>
<h3 id="发送快照"><a href="#发送快照" class="headerlink" title="发送快照"></a>发送快照</h3><p>快照的发送由leader到follower。通常发生在leader发送心跳数据(包括append log)时，leader发现follower的log落后于leader太远时，会把自己的快照发送给follower。</p>
<p>具体到代码实现上，leader平时使用nextIndex数组来和follower协商，下次发送从哪里开始的log。当leader发现，nextIndex数组已经匹配到自己已经抛弃的log的index时(这些log在建立好快照后被抛弃)，就需要发送snapshot数据而非发送log数据。具体的RPC参数可见原论文的图。</p>
<h3 id="安装快照"><a href="#安装快照" class="headerlink" title="安装快照"></a>安装快照</h3><p>安装快照涉及到service层和raft层的互动，比较麻烦。</p>
<p>首先由Leader向follower发送快照数据。follower收到这些数据后，向service层的applyCh写入一条通知，通知的内容就是需要安装快照。然后service层首先调用raft层的condInstallSnapshot，让raft判断是否安装这个快照（如果raft层已经拥有这个快照的状态对应的最后一条log，或者raft层已经有比它更新的快照），就不用安装这个快照。否则，需要安装快照。raft层需要将applyIndex设置为快照状态对应的最后一条log的index，然后返回true。service层收到true后，将快照读取，并利用读取的数据重置自己的状态。</p>
<p>全过程中，raft需要重置的数据，是applyIndex。而commitIndex不用重置，因为commitIndex是从leader处获得的。</p>
<h2 id="一些bug"><a href="#一些bug" class="headerlink" title="一些bug"></a>一些bug</h2><ol>
<li>channel不能加锁。这个和RPC调用不能加锁一样，channel加锁可能导致死锁。不知道为什么前几次实验都通过了，这个bug一直到lab3才暴露出来。</li>
</ol>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><img src="../images/lab3A.png" alt="lab3A" style="zoom:40%;" />

<img src="../images/lab3B.png" alt="lab3B" style="zoom:40%;" />]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lab1-buffer pool</title>
    <url>/2021/12/07/lab1-buffer-pool/</url>
    <content><![CDATA[<p>Lab1 的任务是实现一个内存中的关于 DBMS 的 page 的缓存池，并且支持一些关于 page 的操作和管理。因为数据库中的基本单元 page 都存放在磁盘中，因此当需要访问时，我们需要将它 load 到内存的 buffer pool 中，当不需要时再将其写回。</p>
<span id="more"></span>

<p>当然这个操作也可以由 mmap 完成，但课程中说到了我们需要避免 OS 接管，理由有若干：DBMS 知道什么时候是写回 dirty page 的最佳时机；DBMS 可以更好地支持预取；DBMS 的 Page 替换策略可以做到更好；DBMS 的线程调度；总的来说就是因为数据库中的 Page 对 OS 来说只是一块没有意义的文件，因此它只会把它当做一般文件来读入读出；而 DBMS 却了解这个文件的更多信息，借助这些信息可以更高效地 pool。</p>
<h3 id="Task-1-LRU-REPLACEMENT-POLICY"><a href="#Task-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="Task #1 - LRU REPLACEMENT POLICY"></a>Task #1 - LRU REPLACEMENT POLICY</h3><p>任务1需要我们完成一个基于 LRU 的 Frame 淘汰策略算法。整个 buffer pool 是一个固定大小的 Frame 数组，一个 Frame 只能缓存1页 Page。因此当 buffer pool 中的所有 Frame 都缓存了 Page，但此时还需要 load 新的 Page 时，就需要先写回到 disk 一些 Page，把对应的 Frame 空出来，然后再容纳新的 Page。我们要做的事情，就是追踪这些 Frame 的使用情况，当 Frame 都满，且需要空的 Frame 时，把最久不访问的 Frame 内的 Page 写回。</p>
<p>具体地，我们需要实现一个 LruReplacer 类，这个类负责维护所有 unpin 的 Page 所在的 FrameId。当有一个 Page 被 Unpin 时(pin count 为0时会被 unpin)，我们将它所在的 Frame 的 FrameId 收纳进来，以表示此 Frame 可以被淘汰，而淘汰的时机就按照被 Unpin的先后顺序（用 unpin 的顺序代表最近被用过的顺序）。 </p>
<p>Unpin函数调用时，向  LruReplacer 中添加一个 FrameId；Pin把  LruReplacer 中的 FrameId 移除，表示该 FrameId 不再是 可被换出的；Victim 表示根据 LRU 的策略选择一个 Frame 换出；</p>
<p>具体实现方面，可以用一个双向链表表示 LRU 的节点，为了更快找到中间结点，可以用 hashMap 保存链表上每个节点的位置；还有一种办法可以只用哈希表，即 哈希表内的每个 value中，保存该元素的 pre 和 next，就能实现在哈希表上的双向链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">frame_id_t</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt;::iterator&gt; hash_table_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">frame_id_t</span>&gt; lru_link_list_;</span><br></pre></td></tr></table></figure>

<p>最后，由于 Replacer 会被多个线程访问，因此需要 mutex 保护。LruReplacer 继承自虚基类 Replacer，看得出来后续实验我们可能会用到不止一种 Replacer，因此 lab 把 Replacer 做成了虚基类。</p>
<h3 id="Task-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#Task-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="Task #2 - BUFFER POOL MANAGER INSTANCE"></a>Task #2 - BUFFER POOL MANAGER INSTANCE</h3><p>任务2需要实现核心类 BufferPoolManagerInstance。它负责把磁盘中的 Page 调入内存，存储在自己的缓冲池中。首先明确几个概念，</p>
<ul>
<li>frame：页框，内存中的一个位置，其大小可容纳一个 Page，可视为一个物理概念。一个 frame 的数组就构成了 buffer pool，frame 由 frame Id 标识，frame Id 即 frame 数组的 idx。</li>
<li>Page：页，逻辑概念，Page 存放在 disk 中或者 内存中，由 buffer pool 负责调度。Page 内部有一些元信息，关键的有：pageId、pin count、dirty位</li>
<li>PageTable：页表。负责记录<strong>在 buffer pool中</strong>的 Page 的位置信息(在哪个 Frame 中存储)</li>
</ul>
<p>frame 是容纳 page 的单位，下图中我们以 frame 为中心分析 buffer pool 中页的状态。</p>
<img src="../images/page_frame.png" alt="image-20211207205436894" style="zoom:50%;" />

<p>buffer pool 维护了一个空闲链表，内容是所有空闲的 Frame 的id，因此空闲链表内的 Frame 中的 Page 都是无意义的空 Page；而 Replacer 中维护的是已经 Unpin 的 page 对应的 frame，但这类 page 暂时还留在 buffer pool中，后续可能会被用到而被 pin，也可能会被换出去，因此目前的 pin 肯定为0，dirty 则不确定，因为其目前还在 buffer pool 中，因此它的位置信息还在 page table 中；in use 的page，既不在 free list 中也不再 replacer 中，因为是在 use 的，因此 pin cnt 肯定不为0。</p>
<p>接着就是按照这个状态完成各种函数，其中与 disk 打交道的部分是现成的，读入和写出的操作只需要调用 diskManager 的 API 即可。几个关键函数的实现细节如下</p>
<ul>
<li>NewPgImp ：负责创建新的 Page。首先新生成一个 pageId（pageId 是虚拟的，只要递增不重复就行），然后从 free list 或者 replacer 中搞一个空闲 frame，把这个 frame 初始化为一个新的 page，注意新的 page 的状态应当属于 in use，因此 pin cnt = 1，还需要将其加入到 page table。</li>
<li>UnpinPgImp：修改该 Page 的 pin cnt，当其为0时，调用 Replacer 的 Unpin，这代表将该 Page 的所在 Frame 列为潜在被淘汰对象。</li>
<li>FetchPgImp：fetch 来的 Page 也应该被纳入 In use 状态，其 pin count 需要被修改。</li>
</ul>
<h3 id="Task-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#Task-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="Task #3 - PARALLEL BUFFER POOL MANAGER"></a>Task #3 - PARALLEL BUFFER POOL MANAGER</h3><p>这个任务的大意是说，因为我们的 pool 是支持多线程的，当多个线程一起调入调出 Page 时，由于有锁机制，导致锁争用效率很低。我们可以搞多个 pool，把 PageId 哈希到 pool，一个 pool 只负责一部分 Page 的处理。</p>
<p>关键和容易错的地方只有一个，就是并行版的 NewPgImp。实验要求我们轮询生成 page，即我们要保证轮训给每个 pool 的 page 要一样多。我们可以这么做，维护一个 idx，每次 new page 时就+1，mod pool_num 得到 pool 的id，轮到哪个 pool 就由哪个 pool 来 new page。可能出 bug 的地方在于，由于 ParallelBufferPoolManager 也是被多线程调用的，因此 idx 需要被锁保护以确保其严格按照+1递增，漏掉锁的话会出问题。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>注意事项</p>
<ul>
<li>不要修改实验指定范围以外的类，如果提交时出现 The autograder failed to execute correctly，请检查是不是修改了不允许修改的 class</li>
<li>提交前先进行语法检查，不通过的原因可能是语法不规范导致的</li>
</ul>
<p>最后附上实验结果</p>
<img src="../images/lab1_result.png" alt="image-20211207211733154" style="zoom:50%;" />



]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>lab2-extendible hash index</title>
    <url>/2021/12/19/lab2-extendible-hash-index/</url>
    <content><![CDATA[<p>Lab2 的任务是实现一个可扩充（扩缩容）的哈希索引。这个哈希索引的作用是对数据库内的数据进行索引从而快速查询，以避免在检索时的逐行扫描。哈希索引分为meta-data和bucket，它们都存储在Page上，即整个哈希索引只有一个meta-data结构，它存储于一个Page上，而哈希索引有若干bucket，每个bucket存储在一个Page上。哈希索引通过lab1实现的buffer pool实现对Page的载入和写回。</p>
<h3 id="extendible-hash-index"><a href="#extendible-hash-index" class="headerlink" title="extendible hash index"></a>extendible hash index</h3><p>首先介绍一下extendible hash index算法的原理（详细描述可参考《数据库系统概念》，英文版《Database System Concepts》）。如下图所示为一个extendible hash index。每个虚线框都代表一个Page。左边部分是directory，存储了一个depth，称为global depth，还有一个pageId映射表，存储了每个哈希值对应bucket的pageId。右边是一些bucket，每个bucket都有一个自己的专属depth，称为local depth。</p>
<img src="../images/extendible_hash_index.png" alt="extendible_hash_index" style="zoom:50%;" />

<p>在拿到一个key之后，可扩充索引算法首先求出key的哈希值hash_key，我们假设其有32位，为uint32_t。我们不可能为每个哈希值都建立一个bucket，因为这需要2^32个桶，不现实。可扩充索引的原理是，我们初始的时候全局仅仅建立一个桶，所有key都存放在该桶中，当桶被填满后，我们新建一个桶，把旧桶中一部分元素转移到新桶中(rehash)。那么rehash的原则是什么呢？有一个办法，就是根据hash_key的<strong>二进制的尾数</strong>，即最后一位为0的待在原bucket a，最后一位为1的转移到新bucket b。此时，全局就有了两个桶a和b，以后新的待插入key都要根据其hash_key的最后一位是0还是1来决定放入哪个桶。当两个桶中的某个满了(假设为b，它原本接受hash_key位数为1的所有key)，我们就再新建一个桶c，把b的一部分数据转移到新桶c中，转移的原则是什么呢？现在就该根据hash_key的后2位来决定了。因为如果考虑后两位数的话，原本hash_key最后1位尾数为1的所有key可以分为两位尾数为01和11的，如果其最后2位尾数为01，则待在原桶b，否则若尾数为11，则转移至c桶。然后，当转移完key之后，我们还要考虑后续新来的key如何做插入。我们可以说，我们现在看新来的key的hash_key的二进制后两位，若后key的后两位为00、10，就放在a中（第一次分裂的规则一致）。若key的后两位为01，则插入桶b，后两位为11，插入桶c。</p>
<p>这就是extendible hash index的原理，可以看出，决定待插入key该放在哪个桶，应该看key的哈希值hash_key的二进制数的最后若干位，这就是global depth的用处。而local depth的作用是决定如何进行桶的分裂。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询主要依靠global depth。对于某个待查询的key，我们首先用哈希函数h计算其哈希值hash_key（这里的h有若干选择，如CRC32、murmur Hash等）。然后我们根据global depth，获取hash_key的二进制形式的最后global depth位，将其作为索引数字idx，然后找到directory中pageId映射表的第idx个位置，查看其对应的bucket的page_id是多少。然后凭借page_id拿到bucket，在bucket内部顺序检索即可(可以做一些优化，如设置墓碑标记，使得顺序查找可以提前结束)。</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>简单的插入原则和查询一致。但当插入导致bucket溢出时，我们需要做bucket的分裂。</p>
<p>首先检查溢出bucket的local depth，若local depth小于global depth，我们只用做bucket split；如果local depth等于global depth，则先做directory expandsion，然后再做bucket split。</p>
<ul>
<li>directory expandsion：这是一个将directory double的过程，我们只需要改动directory<ul>
<li>global depth 加一</li>
<li>将pageId映射表大小变为原来的2倍，并填充新增表项的内容</li>
</ul>
</li>
<li>bucket split：我们需要新建一个bucket，然后把溢出的bucket内的一部分key转移到新bucket中，然后在directory中做一定的改动<ul>
<li>溢出bucket的local depth加一</li>
<li>根据溢出bucket的local depth，决定bucket中的表项是否转移至新bucket，并转移</li>
<li>设置新bucket在directory中的索引</li>
<li>遍历pageId映射表，把原来指向溢出bucket的表项中，一半的表项指向新的bucket</li>
</ul>
</li>
<li>directory的性质<ul>
<li>如果一个bucket的local_depth小于directory的global_depth，则directory中会有多个idx指向该bucket。具体个数为2^(global_depth -local_depth )。</li>
<li>global_depth主要用于key到bucket的导航；local depth主要用于split和merge时发现镜像pair。</li>
</ul>
</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>简单的删除原则和查询一致。但当删除导致bucket为空时，需要做bucket的merge（这里比较严格，实际上可以是bucket的占用率低于某个条件就做merge，可以人为规定merge时机）。</p>
<ul>
<li>merge的几个条件<ul>
<li>当前bucket为空时，才对它进行merge</li>
<li>当前bucket的local_depth必须和其image_bucket的local_depth相等</li>
<li>当前bucket的local_depth必须大于0</li>
</ul>
</li>
<li>merge过程<ul>
<li>将当前bucket的page删除</li>
<li>把原本指向当前bucket的<strong>所有</strong>pageId映射表表项，修改为指向image_bucket；</li>
<li>检查所有local depth，如果所有的local depth都小于global depth，则可以将global depth减一</li>
</ul>
</li>
</ul>
<h3 id="CONCURRENCY-CONTROL"><a href="#CONCURRENCY-CONTROL" class="headerlink" title="CONCURRENCY CONTROL"></a>CONCURRENCY CONTROL</h3><p>我们需要对哈希索引做并发控制，使得其支持多线程访问。我们使用两类锁配合实现并发控制：table_lock 和 bucket_lock。table_lock只有一个，用于保护directory，可以以读模式和写模式获取。bucket_lock每个bucket有一个，用于保护单个bucket的读写。</p>
<p>具体的实现逻辑如下</p>
<h4 id="insert-amp-split"><a href="#insert-amp-split" class="headerlink" title="insert &amp; split"></a>insert &amp; split</h4><p>插入操作需要<strong>全程在directory读锁的保护下进行</strong>，以确保插入过程中diectory不会变动。此外我们还需要对应bucket的写锁。</p>
<p>我们首先在directory读锁和bucket写锁的保护下检测bucket是否满，如果不满则直接插入并返回。</p>
<p>如果bucket是满的，则需要做split。我们先释放之前获取的锁，然后请求directory的写锁。然后做split_and_insert。因为释放之前的锁和请求directory的写锁之间不是原子的，会有时间间隙，在这段时间内bucket可能又是不满的了，因此我们在split_and_insert内再次先判断一下bucket是否满，如果满了，再做split，否则直接insert。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">  table_lock.read_lock();</span><br><span class="line">  bucket_lock.write_lock();</span><br><span class="line">  <span class="comment">//try to insert</span></span><br><span class="line">  <span class="keyword">bool</span> succeed;</span><br><span class="line">  <span class="keyword">if</span>(bucket is <span class="keyword">not</span> full)&#123;</span><br><span class="line">    succeed = bucket_insert(...);</span><br><span class="line">  	bucket_lock.write_unlock();</span><br><span class="line">    table_lock.read_unlock();</span><br><span class="line">    <span class="keyword">return</span> succeed;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	bucket_lock.write_unlock();</span><br><span class="line">    table_lock.read_unlock();</span><br><span class="line">    <span class="comment">//use table write lock to split and insert</span></span><br><span class="line">    table_lock.write_lock();</span><br><span class="line">    succeed = split_and_insert(...);</span><br><span class="line">    table_lock.write_unlock();</span><br><span class="line">    <span class="keyword">return</span> succeed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">split_and_insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(bucket is full)&#123;</span><br><span class="line">    <span class="comment">//do split</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bucket_insert(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-amp-merge"><a href="#delete-amp-merge" class="headerlink" title="delete &amp; merge"></a>delete &amp; merge</h4><p>和上面的同理。我们在directory的读锁和bucket的写锁保护下，先删除元素，然后顺便探测一下是否需要merge。如果需要，则释放directory的读锁和bucket的写锁，重新申请directory的写锁，然后做merge。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">   table_lock.read_lock();</span><br><span class="line">   bucket_lock.write_lock();</span><br><span class="line">   <span class="keyword">bool</span> succeed = bucket_delete(...);	</span><br><span class="line">   <span class="keyword">if</span>(we need merge)&#123;</span><br><span class="line">   		bucket_lock.write_unlock();</span><br><span class="line">    	table_lock.read_unlock();</span><br><span class="line">     </span><br><span class="line">     	table_lock.write_lock();</span><br><span class="line">     	merge();</span><br><span class="line">     	table_lock.write_unlock();</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     	bucket_lock.write_unlock();</span><br><span class="line">    	table_lock.read_unlock();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> succeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>一些注意事项</p>
<ul>
<li>split需要实现成循环的。因为一次split后，bucket可能还是满的</li>
<li>我们new一个page、fetch一个page后默认已经pin了，因此我们只需要注意unpin时机，以及dirty的设置</li>
<li>bucket lock是在page上存储的，为防止还没释放锁page就被换出了，必须先解锁再unpin bucket page；table_lock则无所谓</li>
<li>gdb 调试作用不大。一般错误主要出在split和merge上，善用PrintDirectory和PrintBucket就行。</li>
<li>实验代码提供了检验directory完整性的函数VerifyIntegrity（依据directory的性质实现），可以在每次split或merge后调用一下，帮你发现一些问题</li>
</ul>
<p>附上实验结果</p>
<img src="../images/lab2_result.png" alt="lab2_result" style="zoom:50%;" />

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
